{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Verticox+ is a Cox proportional hazards algorithm for vertically distributed data.</p> <p>The solution is based on the Verticox algorithm from Dai et al., 2022. It has been adapted to be used within the Vantage6 framework.</p> <p>This solution is extended with the scalar vector product protocol (van Daalen et al.) to solve certain privacyconcerns in \"vanilla\" Verticox.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>The main way to use verticox+ is to run it within a vantage6 environment. For more info on vantage6,  see the vantage6 documentation.</p> <p>When you have a vantage6 environment running either locally or remotely, you can test out verticox by running the demo.</p>"},{"location":"#theory","title":"Theory","text":"<p>The original Verticox pseudocode can be summarized as below. The full pseudocode can be found in the original paper by Dai et al.</p>"},{"location":"#algorithm-1-original-verticox-algorithm","title":"Algorithm 1: Original Verticox Algorithm","text":"<p>Input: Local data at each party Output: Converged Cox proportional hazard model</p> <ol> <li>Initialization</li> <li>While stopping criterion has not been reached:<ol> <li>For each party \\( k \\):<ul> <li>Solve \\( \\beta_{k}^{p} \\)</li> <li>Compute \\( \\sigma_{nk} = \\beta_k^T x_{nk} \\)</li> <li>Send \\( \\sigma_{nk} \\) to the central server</li> </ul> </li> <li>Server aggregates subresults</li> <li>Server calculates auxiliary value \\( \\overline{z^{p}} \\)</li> <li>Server updates \\( z_{nk}^{p} \\)</li> <li>Server sends \\( z_{nk}^{p} \\) and aggregation to parties</li> <li>Local parameters are updated</li> </ol> </li> </ol> <p>The main privacy issue lies within solving \\( \\beta_{k}^{p} \\). This is done using the following equation:</p> \\[ \\beta_{k}^{p} = \\left[ \\rho \\sum_{n=1}^{N} x_{nk}^{T}x_{nk} \\right]^{-1} \\cdot \\left[ \\sum_{n=1}^{N} (\\rho z_{nk}^{p-1} - \\gamma_{nk}^{p-1} ) x_{nk}^{T} + \\sum_{t=1}^{T}\\sum_{n\\in E_{t}}x_{nk} \\right] \\] <p>The problem lies in the last part of the equation: \\( \\sum_{t=1}^{T}\\sum_{n\\in E_{t}}x_{nk} \\). This part references \\( E_{t} \\), which is the index set of samples with an observed event at time \\( t \\). Therefore, for every time \\( t \\), we need to select the samples with an observed event. This requires the availability of outcome data at every party, which is not always possible in real-world use cases.</p> <p>Verticox+ will solve this problem by using the scalar-product protocol. To do that, we translate the inner sum \\( \\sum_{n\\in E_{t}}x_{nk} \\) to a scalar product:</p> \\[ u_{kt} = x_{k} \\cdot \\overrightarrow{(E_{t})} \\] <p>In this case, \\( \\overrightarrow{(E_{t})} \\) is a Boolean vector of length \\( N \\) that indicates for each sample whether it had an event at time \\( t \\) (indicated as 1) or not (indicated as 0). \\( \\beta_k^{p} \\) will now be solved according to the following equation:</p> \\[ \\beta_{k}^{p} = \\left[ \\rho \\sum_{n=1}^{N} x_{tnk}^{T}x_{tnk} \\right]^{-1} \\cdot \\left[ \\sum_{n=1}^{N} (\\rho z_{nk}^{p-1} - \\gamma_{nk}^{p-1} ) x_{nk}^{T} + \\sum_{t=1}^{T} u_{kt} \\right] \\] <p>Authors:</p> <ul> <li>Djura Smits d.smits@esciencecenter.nl</li> <li>Florian van Daalen f.vandaalen@maastrichtuniversity.nl</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#verticox.vantage6.column_names","title":"<code>column_names(data, *args, **kwargs)</code>","text":"<p>Returns the names of the columns in the data. Useful to investigate the dataset before running the actual algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>v6 client provided by the algorithm wrapper</p> required <code>data</code> <code>DataFrame</code> <p>dataframe containing the data, provided by algorithm wrapper</p> required <p>Returns: a list of column names</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\ndef column_names(data: pd.DataFrame, *args, **kwargs):\n    \"\"\"\n    Returns the names of the columns in the data. Useful to investigate the dataset before\n    running the actual algorithm.\n\n\n    Args:\n        client: v6 client provided by the algorithm wrapper\n        data: dataframe containing the data, provided by algorithm wrapper\n\n    Returns: a list of column names\n\n    \"\"\"\n    return data.columns.tolist()\n</code></pre>"},{"location":"api/#verticox.vantage6.cross_validate","title":"<code>cross_validate(client, data, feature_columns, event_times_column, event_happened_column, include_value=True, datanode_ids=None, central_node_id=None, convergence_precision=DEFAULT_PRECISION, rho=DEFAULT_RHO, n_splits=DEFAULT_KFOLD_SPLITS, *_args, **_kwargs)</code>","text":"<p>Fit a cox proportional hazards model using the Verticox+ algorithm using crossvalidation. Works similarly to the <code>fit</code> method, but trains multiple times on smaller subsets of the data using k-fold crossvalidation.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AlgorithmClient</code> <p>v6 client provided by the algorithm wrapper</p> required <code>data</code> <code>DataFrame</code> <p>dataframe containing the data, provided by algorithm wrapper</p> required <code>feature_columns</code> <code>List[str]</code> <p>The columns to be used as features</p> required <code>event_times_column</code> <code>str</code> <p>The name of the column that contains the event times</p> required <code>event_happened_column</code> <code>str</code> <p>The name of the column that contains whether an event has happened,</p> required <code>include_value</code> <p>The value in the event_happened_column that means the record is NOT right-censored</p> <code>True</code> <code>datanode_ids</code> <code>List[int]</code> <p>List of organization ids of the nodes that will be used as feature nodes</p> <code>None</code> <code>central_node_id</code> <code>int</code> <p>Organization id of the node that will be used as the central node. This</p> <code>None</code> <code>convergence_precision</code> <code>float</code> <p>Precision for the Cox model. The algorithm will stop when the difference</p> <code>DEFAULT_PRECISION</code> <code>rho</code> <code>float</code> <p>Penalty parameter</p> <code>DEFAULT_RHO</code> <code>n_splits</code> <code>int</code> <p>Number of splits for crossvalidation</p> <code>DEFAULT_KFOLD_SPLITS</code> <code>*_args</code> <code>()</code> <code>**_kwargs</code> <code>{}</code> <p>Returns:  A tuple containing 3 lists: <code>c_indices</code>, <code>coefs</code>, <code>baseline_hazards</code></p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\n@algorithm_client\ndef cross_validate(client: AlgorithmClient,\n                   data: pd.DataFrame,\n                   feature_columns: List[str],\n                   event_times_column: str,\n                   event_happened_column: str,\n                   include_value=True,\n                   datanode_ids: List[int] = None,\n                   central_node_id: int = None,\n                   convergence_precision: float = DEFAULT_PRECISION,\n                   rho: float = DEFAULT_RHO,\n                   n_splits: int = DEFAULT_KFOLD_SPLITS,\n                   *_args,\n                   **_kwargs):\n    \"\"\"\n    Fit a cox proportional hazards model using the Verticox+ algorithm using crossvalidation.\n    Works similarly to the `fit` method, but trains multiple times on smaller subsets of the data\n    using k-fold crossvalidation.\n\n    Args:\n        client: v6 client provided by the algorithm wrapper\n        data: dataframe containing the data, provided by algorithm wrapper\n        feature_columns: The columns to be used as features\n        event_times_column: The name of the column that contains the event times\n        event_happened_column: The name of the column that contains whether an event has happened,\n        or whether the sample is right censored.\n        include_value: The value in the event_happened_column that means the record is NOT right-censored\n        datanode_ids: List of organization ids of the nodes that will be used as feature nodes\n        central_node_id:  Organization id of the node that will be used as the central node. This\n        node should contain the outcome data.\n        between iterations falls below this number\n        convergence_precision: Precision for the Cox model. The algorithm will stop when the difference\n        rho: Penalty parameter\n        n_splits: Number of splits for crossvalidation\n        *_args:\n        **_kwargs:\n\n    Returns:  A tuple containing 3 lists: `c_indices`, `coefs`, `baseline_hazards`\n\n    \"\"\"\n\n    manager = node_manager.V6NodeManager(\n        client,\n        data,\n        datanode_ids,\n        central_node_id,\n        event_happened_column,\n        event_times_column,\n        feature_columns,\n        include_value,\n        convergence_precision=convergence_precision,\n        rho=rho,\n    )\n    try:\n        info(f\"Start running verticox on features: {feature_columns}\")\n\n        manager.start_nodes()\n\n        start_time = time.time()\n        c_indices, coefs, baseline_hazards = kfold_cross_validate(manager, n_splits=n_splits)\n        end_time = time.time()\n        duration = end_time - start_time\n        info(f\"Verticox algorithm complete after {duration} seconds\")\n\n        info(\"Killing datanodes\")\n        # Make baseline hazard functions serializable\n        baseline_hazards = [_stepfunction_to_tuple(f) for f in baseline_hazards]\n\n        print(f'Returning c_indices: {c_indices}\\ncoefs: {coefs}\\nbaseline_hazards: {baseline_hazards}')\n        return c_indices, coefs, baseline_hazards\n    except Exception as e:\n        info(f\"Algorithm ended with exception {e}\")\n        info(traceback.format_exc())\n    finally:\n        manager.kill_all_algorithms()\n</code></pre>"},{"location":"api/#verticox.vantage6.fit","title":"<code>fit(client, data, feature_columns, event_times_column, event_happened_column, include_value=True, datanode_ids=None, central_node_id=None, precision=DEFAULT_PRECISION, rho=DEFAULT_RHO, database=None, *_args, **_kwargs)</code>","text":"<p>Fit a cox proportional hazards model using the Verticox+ algorithm</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AlgorithmClient</code> <p>v6 client provided by the algorithm wrapper</p> required <code>data</code> <code>DataFrame</code> <p>dataframe containing the data, provided by algorithm wrapper</p> required <code>feature_columns</code> <code>List[str]</code> <p>The columns to be used as features</p> required <code>event_times_column</code> <code>str</code> <p>The name of the column that contains the event times</p> required <code>event_happened_column</code> <code>str</code> <p>The name of the column that contains whether an event has happened,</p> required <code>include_value</code> <code>any</code> <p>The value in the event_happened_column that means the record is NOT right-censored</p> <code>True</code> <code>datanode_ids</code> <code>List[int]</code> <p>List of organization ids of the nodes that will be used as feature nodes</p> <code>None</code> <code>central_node_id</code> <code>int</code> <p>Organization id of the node that will be used as the central node. This</p> <code>None</code> <code>precision</code> <code>float</code> <p>Precision for the Cox model. The algorithm will stop when the difference</p> <code>DEFAULT_PRECISION</code> <code>rho</code> <code>float</code> <p>Penalty parameter</p> <code>DEFAULT_RHO</code> <code>database</code> <code>str | None</code> <p>Name of the database to be used (default is \"default\")</p> <code>None</code> <code>*_args</code> <code>()</code> <code>**_kwargs</code> <code>{}</code> <p>Returns: A dictionary containing the coefficients of the model (\"coefs\") and the baseline hazard function of the model (\"baseline_hazard_x\" and \"baseline_hazard_y\").</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\n@algorithm_client\ndef fit(\n        client: AlgorithmClient,\n        data: pd.DataFrame,\n        feature_columns: List[str],\n        event_times_column: str,\n        event_happened_column: str,\n        include_value: any = True,\n        datanode_ids: List[int] = None,\n        central_node_id: int = None,\n        precision: float = DEFAULT_PRECISION,\n        rho: float = DEFAULT_RHO,\n        database: str|None = None,\n        *_args,\n        **_kwargs,\n):\n    \"\"\"\n    Fit a cox proportional hazards model using the Verticox+ algorithm\n\n    Args:\n        client: v6 client provided by the algorithm wrapper\n        data: dataframe containing the data, provided by algorithm wrapper\n        feature_columns: The columns to be used as features\n        event_times_column: The name of the column that contains the event times\n        event_happened_column: The name of the column that contains whether an event has happened,\n        or whether the sample is right censored.\n        include_value: The value in the event_happened_column that means the record is NOT right-censored\n        datanode_ids: List of organization ids of the nodes that will be used as feature nodes\n        central_node_id:  Organization id of the node that will be used as the central node. This\n        node should contain the outcome data.\n        precision: Precision for the Cox model. The algorithm will stop when the difference\n        between iterations falls below this number\n        rho: Penalty parameter\n        database: Name of the database to be used (default is \"default\")\n        *_args:\n        **_kwargs:\n\n    Returns: A dictionary containing the coefficients of the model (\"coefs\") and the baseline\n    hazard function of the model (\"baseline_hazard_x\" and \"baseline_hazard_y\").\n    \"\"\"\n\n    # Preprocessing data\n    # TODO: This can removed once we move to v6 version 5.x\n    columns = Columns(feature_columns, event_times_column, event_happened_column)\n    data, columns, data_location = preprocess_data(data, output_dir=DATABASE_DIR,columns=columns )\n\n    info(f\"Columns: {columns}\")\n\n    manager = node_manager.V6NodeManager(\n        client,\n        data,\n        datanode_ids,\n        central_node_id,\n        columns.event_happened_column,\n        columns.event_times_column,\n        columns.feature_columns,\n        include_value,\n        convergence_precision=precision,\n        rho=rho,\n        database=database,\n    )\n    try:\n        info(f\"Start running verticox on features: {feature_columns}\")\n\n        manager.start_nodes()\n\n        start_time = time.time()\n        manager.fit()\n        end_time = time.time()\n        duration = end_time - start_time\n        info(f\"Verticox algorithm complete after {duration} seconds\")\n\n        info(\"Killing datanodes\")\n        return {\"coefs\": manager.coefs,\n                \"baseline_hazard_x\": list(manager.baseline_hazard.x),\n                \"baseline_hazard_y\": list(manager.baseline_hazard.y)\n                }\n    except Exception as e:\n        info(f\"Algorithm ended with exception {e}\")\n        info(traceback.format_exc())\n    finally:\n        manager.kill_all_algorithms()\n</code></pre>"},{"location":"api/#verticox.vantage6.no_op","title":"<code>no_op(*args, **kwargs)</code>","text":"<p>A function that does nothing for a while. It is used as a partial algorithm within the verticox+ algorithm and and should not be called by itself.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> <p>Returns:</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\ndef no_op(*args, **kwargs):\n    \"\"\"\n    A function that does nothing for a while. It is used as a partial algorithm within the verticox+\n    algorithm and and should not be called by itself.\n\n    Args:\n        *args:\n        **kwargs:\n\n    Returns:\n\n    \"\"\"\n    info(f\"Sleeping for {NO_OP_TIME}\")\n    time.sleep(NO_OP_TIME)\n    info(\"Shutting down.\")\n</code></pre>"},{"location":"api/#verticox.vantage6.run_datanode","title":"<code>run_datanode(data, *args, selected_columns=(), event_time_column=None, include_column=None, include_value=None, external_commodity_address=None, address=None, **kwargs)</code>","text":"<p>Starts the datanode (feature node) as gRPC server. This function is a partial function called by the main verticox algorithm. It is not meant to be called by itself.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>the entire dataset, provided by the algorithm wrapper</p> required <code>include_value</code> <code>bool | None</code> <p>This value in the data means the record is NOT right-censored</p> <code>None</code> <code>selected_columns</code> <code>List[str]</code> <p>the names of the columns that will be treated as features (covariants) in</p> <code>()</code> <code>event_time_column</code> <code>str | None</code> <p>the name of the column that indicates event time</p> <code>None</code> <code>include_column</code> <code>str | None</code> <p>the name of the column that indicates whether an event has taken                     place or whether the sample is right censored. If the value is                     False, the sample is right censored.</p> <code>None</code> <code>external_commodity_address</code> <code>str | None</code> <p>Address of the n-party product protocol commodity server</p> <code>None</code> <code>address</code> <p>The address where this server will be running.</p> <code>None</code> <p>Returns: None</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\ndef run_datanode(\n        data: pd.DataFrame,\n        *args,\n        selected_columns: List[str] = (),\n        event_time_column: str|None = None,\n        include_column: str|None = None,\n        include_value: bool|None = None,\n        external_commodity_address: str|None = None,\n        address=None,\n        **kwargs,\n):\n    \"\"\"\n    Starts the datanode (feature node) as gRPC server. This function is a partial function called by\n    the main verticox algorithm. It is not meant to be called by itself.\n\n    Args:\n        data: the entire dataset, provided by the algorithm wrapper\n        include_value: This value in the data means the record is NOT right-censored\n        selected_columns: the names of the columns that will be treated as features (covariants) in\n        the analysis\n        event_time_column: the name of the column that indicates event time\n        include_column: the name of the column that indicates whether an event has taken\n                                place or whether the sample is right censored. If the value is\n                                False, the sample is right censored.\n        external_commodity_address: Address of the n-party product protocol commodity server\n        address: The address where this server will be running.\n\n    Returns: None\n\n\n    \"\"\"\n    info(f\"Selected columns: {selected_columns}\")\n    info(f\"Columns present in dataset: {data.columns}\")\n    info(f\"Event time column: {event_time_column}\")\n    info(f\"Censor column: {include_column}\")\n\n\n    columns = Columns(selected_columns, None, None)\n\n    features, new_columns = preprocess_data(data, columns)\n\n    # The current datanode might not have all the features\n    selected_columns = [f for f in new_columns.feature_columns if f in data.columns]\n    info(f\"Feature columns after filtering: {selected_columns}\")\n    features = data[selected_columns]\n\n    datanode.serve(\n        data=features.values,\n        feature_names=selected_columns,\n        port=node_manager.PYTHON_PORT,\n        include_column=include_column,\n        include_value=include_value,\n        commodity_address=external_commodity_address,\n        address=address,\n    )\n</code></pre>"},{"location":"api/#verticox.vantage6.run_java_server","title":"<code>run_java_server(_data, *_args, features=None, event_times_column=None, event_happened_column=None, **kwargs)</code>","text":"<p>Partial function that starts the java server. This function is called by the main verticox+ algorithm (<code>fit</code> or <code>cross_validate</code>) and should not be called by itself. Args:     _data: data provided by the vantage6 algorithm wrapper     _args:     features: list of column names that will be used as features     event_times_column: Name of the column that contains the event times     event_happened_column: Name of the column that contains whether an event has happened,     or whether the sample is right-censored     *kwargs:</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\ndef run_java_server(_data: pd.DataFrame, *_args, features=None,\n                    event_times_column=None,\n                    event_happened_column=None, **kwargs):\n    \"\"\"\n    Partial function that starts the java server. This function is called by the main verticox+\n    algorithm (`fit` or `cross_validate`) and should not be called by itself.\n    Args:\n        _data: data provided by the vantage6 algorithm wrapper\n        *_args:\n        features: list of column names that will be used as features\n        event_times_column: Name of the column that contains the event times\n        event_happened_column: Name of the column that contains whether an event has happened,\n        or whether the sample is right-censored\n        **kwargs:\n\n    \"\"\"\n    info(\"Starting java server\")\n    command = _get_java_command()\n    info(f\"Running command: {command}\")\n    #target_uri = _move_parquet_file(database)\n\n    columns = Columns(features, event_times_column, event_happened_column)\n    data, column_names, data_path = preprocess_data(_data, columns, _get_data_dir())\n\n    subprocess.run(command, env=_get_workaround_sysenv(data_path))\n</code></pre>"},{"location":"api/#verticox.vantage6.test_sum_local_features","title":"<code>test_sum_local_features(data, features, mask, *args, **kwargs)</code>","text":"<p>Obsolete</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> required <code>features</code> <code>List[str]</code> required <code>mask</code> required <code>*args</code> <code>()</code> <code>**kwargs</code> <code>{}</code> <p>Returns:</p> Source code in <code>python/verticox/vantage6.py</code> <pre><code>@data(1)\ndef test_sum_local_features(\n        data: pd.DataFrame, features: List[str], mask, *args, **kwargs\n):\n    \"\"\"\n    Obsolete\n\n    Args:\n        data:\n        features:\n        mask:\n        *args:\n        **kwargs:\n\n    Returns:\n\n    \"\"\"\n    # Only check requested features\n    data = data[features]\n\n    # Exclude censored data\n    data = data[mask]\n\n    return data.sum(axis=0).values\n</code></pre>"},{"location":"api/#verticox.client.CrossValResult","title":"<code>CrossValResult</code>  <code>dataclass</code>","text":"<p>CrossValResult contains the result of a cross-validation task. It contains the c-indices, coefficients and baseline hazard functions for each fold.</p> Source code in <code>python/verticox/client.py</code> <pre><code>@dataclass\nclass CrossValResult:\n    \"\"\"\n    CrossValResult contains the result of a cross-validation task. It contains the c-indices,\n    coefficients and baseline hazard functions for each fold.\n    \"\"\"\n    c_indices: List[float]\n    coefs: List[Dict[str, float]]\n    baseline_hazards: List[HazardFunction]\n\n    @staticmethod\n    def parse(partialResults: list[dict]):\n        # Cross validation should only have one partial result\n        result = partialResults[0][\"result\"]\n        result = json.loads(result)\n        c_indices, coefs, baseline_hazards = result\n        baseline_hazards = [HazardFunction(*h) for h in baseline_hazards]\n\n        return CrossValResult(c_indices, coefs, baseline_hazards)\n\n    def plot(self):\n        num_folds = len(self.c_indices)\n        fig, ax = plt.subplots(num_folds, 2, constrained_layout=True)\n\n        for fold in range(num_folds):\n            ax[fold][0].plot(self.baseline_hazards[fold].x, self.baseline_hazards[fold].y)\n            ax[fold][0].set_title(f\"Baseline hazard fold {fold}\")\n            ax[fold][1].bar(self.coefs[fold].keys(), self.coefs[fold].values())\n            ax[fold][1].set_title(f\"Coefficients fold {fold}\")\n</code></pre>"},{"location":"api/#verticox.client.FitResult","title":"<code>FitResult</code>  <code>dataclass</code>","text":"<p>FitResult contains the result of a fit task. It contains the coefficients and the baseline hazard function.</p> Source code in <code>python/verticox/client.py</code> <pre><code>@dataclass\nclass FitResult:\n    \"\"\"\n    FitResult contains the result of a fit task. It contains the coefficients and the baseline\n    hazard function.\n    \"\"\"\n    coefs: Dict[str, float]\n    baseline_hazard: HazardFunction\n\n    @staticmethod\n    def parse(results: List[Dict[str, any]]):\n        # Assume that there is only one \"partial\" result\n        content = json.loads(results[0][\"result\"])\n\n        coefs = content[\"coefs\"]\n        baseline_hazard = HazardFunction(content[\"baseline_hazard_x\"], content[\"baseline_hazard_y\"])\n\n        return FitResult(coefs, baseline_hazard)\n\n    def plot(self):\n        fig, ax = plt.subplots(2, 1, constrained_layout=True)\n        ax[0].plot(self.baseline_hazard.x, self.baseline_hazard.y)\n        ax[0].set_title(\"Baseline hazard\")\n        ax[0].set_xlabel(\"time\")\n        ax[0].set_ylabel(\"hazard score\")\n        ax[1].bar(self.coefs.keys(), self.coefs.values(), label=\"coefficients\")\n        ax[1].set_title(\"Coefficients\")\n</code></pre>"},{"location":"api/#verticox.client.Task","title":"<code>Task</code>","text":"<p>Task is a wrapper around the vantage6 task object.</p> Source code in <code>python/verticox/client.py</code> <pre><code>class Task:\n    \"\"\"\n    Task is a wrapper around the vantage6 task object.\n    \"\"\"\n    def __init__(self, client: Client, task_data):\n        self._raw_data = task_data\n        self.client = client\n        self.task_id = task_data[\"id\"]\n\n    def get_results(self) -&gt; PartialResult:\n        \"\"\"\n        Get the results of the task. This will block until the task is finished.\n\n        Returns:\n\n        \"\"\"\n        results = self.client.wait_for_results(self.task_id)\n        return self._parse_results(results[\"data\"])\n\n\n    @staticmethod\n    def _parse_results(results) -&gt; FitResult| CrossValResult:\n        return results\n</code></pre>"},{"location":"api/#verticox.client.Task.get_results","title":"<code>get_results()</code>","text":"<p>Get the results of the task. This will block until the task is finished.</p> <p>Returns:</p> Source code in <code>python/verticox/client.py</code> <pre><code>def get_results(self) -&gt; PartialResult:\n    \"\"\"\n    Get the results of the task. This will block until the task is finished.\n\n    Returns:\n\n    \"\"\"\n    results = self.client.wait_for_results(self.task_id)\n    return self._parse_results(results[\"data\"])\n</code></pre>"},{"location":"api/#verticox.client.VerticoxClient","title":"<code>VerticoxClient</code>","text":"<p>Client for running verticox. This client is a wrapper around the vantage6 client to simplify use.</p> Source code in <code>python/verticox/client.py</code> <pre><code>class VerticoxClient:\n    \"\"\"\n    Client for running verticox. This client is a wrapper around the vantage6 client to simplify\n    use.\n    \"\"\"\n    def __init__(\n            self,\n            v6client: Client,\n            collaboration=None,\n            log_level=logging.INFO,\n            image=DOCKER_IMAGE,\n    ):\n        self._logger = logging.getLogger(__name__)\n        self._logger.setLevel(log_level)\n        self._v6client = v6client\n        self._image = image\n        collaborations = self._v6client.collaboration.list()[\"data\"]\n        if len(collaborations) &gt; 1:\n            raise VerticoxClientException(\n                f\"You are in multiple collaborations, please specify \"\n                f\"one of:\\n {collaborations}\"\n            )\n\n        self.collaboration_id = collaborations[0][\"id\"]\n\n    def get_active_node_organizations(self) -&gt; List[int]:\n        \"\"\"\n        Get the organization ids of the active nodes in the collaboration.\n\n        Returns: a list of organization ids\n\n        \"\"\"\n        nodes = self._v6client.node.list(is_online=True)\n\n        # TODO: Add pagination support\n        nodes = nodes[\"data\"]\n        return [n[\"organization\"][\"id\"] for n in nodes]\n\n    def get_column_names(self, **kwargs):\n        \"\"\"\n        Get the column names of the dataset at all active nodes.\n\n        Args:\n            **kwargs:\n\n        Returns:\n\n        \"\"\"\n        active_nodes = self.get_active_node_organizations()\n        self._logger.debug(f\"There are currently {len(active_nodes)} active nodes\")\n\n        task = self._run_task(\n            \"column_names\", organizations=active_nodes, master=False, **kwargs\n        )\n        return task\n\n    def fit(\n            self,\n            feature_columns,\n            outcome_time_column,\n            right_censor_column,\n            feature_nodes,\n            outcome_node,\n            precision=_DEFAULT_PRECISION,\n            database=\"default\",\n    ):\n        \"\"\"\n        Run cox proportional hazard analysis on the entire dataset.\n\n        Args:\n            feature_columns: a list of column names that you want to use as features\n            outcome_time_column: the column name of the outcome time\n            right_censor_column: the column name of the binary value that indicates if an event\n            happened.\n            feature_nodes: A list of node ids from the datasources that contain the feature columns\n            outcome_node: The node id of the datasource that contains the outcome\n            precision: precision of the verticox algorithm. The smaller the number, the more\n            precise the result. Smaller precision will take longer to compute though. The default is\n            1e-5\n            database: If the nodes have multiple datasources, indicate the label of the datasource\n            you would like to use. Otherwise the default will be used.\n\n        Returns: a `Task` object containing info about the task.\n\n        \"\"\"\n        input_params = {\n            \"feature_columns\": feature_columns,\n            \"event_times_column\": outcome_time_column,\n            \"event_happened_column\": right_censor_column,\n            \"datanode_ids\": feature_nodes,\n            \"central_node_id\": outcome_node,\n            \"precision\": precision,\n        }\n\n        return self._run_task(\n            \"fit\", True, [outcome_node], kwargs=input_params, database=database\n        )\n\n    def cross_validate(self,\n                       feature_columns,\n                       outcome_time_column,\n                       right_censor_column,\n                       feature_nodes,\n                       outcome_node,\n                       precision=_DEFAULT_PRECISION,\n                       n_splits = 10,\n                       database=\"default\"):\n        \"\"\"\n        Run cox proportional hazard analysis on the entire dataset using cross-validation. Uses 10\n        fold by default.\n\n        Args:\n            feature_columns: a list of column names that you want to use as features\n            outcome_time_column: the column name of the outcome time\n            right_censor_column: the column name of the binary value that indicates if an event\n            happened.\n            feature_nodes: A list of node ids from the datasources that contain the feature columns\n            outcome_node: The node id of the datasource that contains the outcome\n            precision: precision of the verticox algorithm. The smaller the number, the more\n            precise the result. Smaller precision will take longer to compute though. The default is\n            1e-5\n            n_splits: The number of folds to use for cross-validation. Default is 10.\n            database: If the nodes have multiple datasources, indicate the label of the datasource\n            you would like to use. Otherwise the default will be used.\n\n        Returns: a `Task` object containing info about the task.\n        \"\"\"\n        input_params = {\n            \"feature_columns\": feature_columns,\n            \"event_times_column\": outcome_time_column,\n            \"event_happened_column\": right_censor_column,\n            \"datanode_ids\": feature_nodes,\n            \"central_node_id\": outcome_node,\n            \"convergence_precision\": precision,\n            \"n_splits\": n_splits,\n        }\n\n        return self._run_task(\n            \"cross_validate\", True, [outcome_node], kwargs=input_params, database=database\n        )\n\n    def _run_task(\n            self, method, master, organizations: List[int], kwargs=None, database=\"default\"\n    ):\n        if kwargs is None:\n            kwargs = {}\n        kwargs[\"database\"] = database\n        # TODO: Construct description out of parameters\n        description = \"\"\n        name = \"method\"\n        task_input = {\"method\": method, \"master\": master, \"kwargs\": kwargs}\n\n        print(\n            f\"\"\"\n                    task = self.v6client.task.create(collaboration={self.collaboration_id},\n                                             organizations={organizations},\n                                             name={name},\n                                             image={self._image},\n                                             description={description},\n                                             input={task_input},\n                                             data_format={_DATA_FORMAT},\n                                             database={database}\n                                             )\n            \"\"\"\n        )\n        task = self._v6client.task.create(\n            collaboration=self.collaboration_id,\n            organizations=organizations,\n            name=name,\n            image=self._image,\n            description=description,\n            input_=task_input,\n            databases=database,\n        )\n\n        match method:\n            case \"fit\":\n                return FitTask(self._v6client, task)\n            case \"cross_validate\":\n                return CrossValTask(self._v6client, task)\n            case _:\n                return Task(self._v6client, task)\n</code></pre>"},{"location":"api/#verticox.client.VerticoxClient.cross_validate","title":"<code>cross_validate(feature_columns, outcome_time_column, right_censor_column, feature_nodes, outcome_node, precision=_DEFAULT_PRECISION, n_splits=10, database='default')</code>","text":"<p>Run cox proportional hazard analysis on the entire dataset using cross-validation. Uses 10 fold by default.</p> <p>Parameters:</p> Name Type Description Default <code>feature_columns</code> <p>a list of column names that you want to use as features</p> required <code>outcome_time_column</code> <p>the column name of the outcome time</p> required <code>right_censor_column</code> <p>the column name of the binary value that indicates if an event</p> required <code>feature_nodes</code> <p>A list of node ids from the datasources that contain the feature columns</p> required <code>outcome_node</code> <p>The node id of the datasource that contains the outcome</p> required <code>precision</code> <p>precision of the verticox algorithm. The smaller the number, the more</p> <code>_DEFAULT_PRECISION</code> <code>n_splits</code> <p>The number of folds to use for cross-validation. Default is 10.</p> <code>10</code> <code>database</code> <p>If the nodes have multiple datasources, indicate the label of the datasource</p> <code>'default'</code> <p>Returns: a <code>Task</code> object containing info about the task.</p> Source code in <code>python/verticox/client.py</code> <pre><code>def cross_validate(self,\n                   feature_columns,\n                   outcome_time_column,\n                   right_censor_column,\n                   feature_nodes,\n                   outcome_node,\n                   precision=_DEFAULT_PRECISION,\n                   n_splits = 10,\n                   database=\"default\"):\n    \"\"\"\n    Run cox proportional hazard analysis on the entire dataset using cross-validation. Uses 10\n    fold by default.\n\n    Args:\n        feature_columns: a list of column names that you want to use as features\n        outcome_time_column: the column name of the outcome time\n        right_censor_column: the column name of the binary value that indicates if an event\n        happened.\n        feature_nodes: A list of node ids from the datasources that contain the feature columns\n        outcome_node: The node id of the datasource that contains the outcome\n        precision: precision of the verticox algorithm. The smaller the number, the more\n        precise the result. Smaller precision will take longer to compute though. The default is\n        1e-5\n        n_splits: The number of folds to use for cross-validation. Default is 10.\n        database: If the nodes have multiple datasources, indicate the label of the datasource\n        you would like to use. Otherwise the default will be used.\n\n    Returns: a `Task` object containing info about the task.\n    \"\"\"\n    input_params = {\n        \"feature_columns\": feature_columns,\n        \"event_times_column\": outcome_time_column,\n        \"event_happened_column\": right_censor_column,\n        \"datanode_ids\": feature_nodes,\n        \"central_node_id\": outcome_node,\n        \"convergence_precision\": precision,\n        \"n_splits\": n_splits,\n    }\n\n    return self._run_task(\n        \"cross_validate\", True, [outcome_node], kwargs=input_params, database=database\n    )\n</code></pre>"},{"location":"api/#verticox.client.VerticoxClient.fit","title":"<code>fit(feature_columns, outcome_time_column, right_censor_column, feature_nodes, outcome_node, precision=_DEFAULT_PRECISION, database='default')</code>","text":"<p>Run cox proportional hazard analysis on the entire dataset.</p> <p>Parameters:</p> Name Type Description Default <code>feature_columns</code> <p>a list of column names that you want to use as features</p> required <code>outcome_time_column</code> <p>the column name of the outcome time</p> required <code>right_censor_column</code> <p>the column name of the binary value that indicates if an event</p> required <code>feature_nodes</code> <p>A list of node ids from the datasources that contain the feature columns</p> required <code>outcome_node</code> <p>The node id of the datasource that contains the outcome</p> required <code>precision</code> <p>precision of the verticox algorithm. The smaller the number, the more</p> <code>_DEFAULT_PRECISION</code> <code>database</code> <p>If the nodes have multiple datasources, indicate the label of the datasource</p> <code>'default'</code> <p>Returns: a <code>Task</code> object containing info about the task.</p> Source code in <code>python/verticox/client.py</code> <pre><code>def fit(\n        self,\n        feature_columns,\n        outcome_time_column,\n        right_censor_column,\n        feature_nodes,\n        outcome_node,\n        precision=_DEFAULT_PRECISION,\n        database=\"default\",\n):\n    \"\"\"\n    Run cox proportional hazard analysis on the entire dataset.\n\n    Args:\n        feature_columns: a list of column names that you want to use as features\n        outcome_time_column: the column name of the outcome time\n        right_censor_column: the column name of the binary value that indicates if an event\n        happened.\n        feature_nodes: A list of node ids from the datasources that contain the feature columns\n        outcome_node: The node id of the datasource that contains the outcome\n        precision: precision of the verticox algorithm. The smaller the number, the more\n        precise the result. Smaller precision will take longer to compute though. The default is\n        1e-5\n        database: If the nodes have multiple datasources, indicate the label of the datasource\n        you would like to use. Otherwise the default will be used.\n\n    Returns: a `Task` object containing info about the task.\n\n    \"\"\"\n    input_params = {\n        \"feature_columns\": feature_columns,\n        \"event_times_column\": outcome_time_column,\n        \"event_happened_column\": right_censor_column,\n        \"datanode_ids\": feature_nodes,\n        \"central_node_id\": outcome_node,\n        \"precision\": precision,\n    }\n\n    return self._run_task(\n        \"fit\", True, [outcome_node], kwargs=input_params, database=database\n    )\n</code></pre>"},{"location":"api/#verticox.client.VerticoxClient.get_active_node_organizations","title":"<code>get_active_node_organizations()</code>","text":"<p>Get the organization ids of the active nodes in the collaboration.</p> <p>Returns: a list of organization ids</p> Source code in <code>python/verticox/client.py</code> <pre><code>def get_active_node_organizations(self) -&gt; List[int]:\n    \"\"\"\n    Get the organization ids of the active nodes in the collaboration.\n\n    Returns: a list of organization ids\n\n    \"\"\"\n    nodes = self._v6client.node.list(is_online=True)\n\n    # TODO: Add pagination support\n    nodes = nodes[\"data\"]\n    return [n[\"organization\"][\"id\"] for n in nodes]\n</code></pre>"},{"location":"api/#verticox.client.VerticoxClient.get_column_names","title":"<code>get_column_names(**kwargs)</code>","text":"<p>Get the column names of the dataset at all active nodes.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>{}</code> <p>Returns:</p> Source code in <code>python/verticox/client.py</code> <pre><code>def get_column_names(self, **kwargs):\n    \"\"\"\n    Get the column names of the dataset at all active nodes.\n\n    Args:\n        **kwargs:\n\n    Returns:\n\n    \"\"\"\n    active_nodes = self.get_active_node_organizations()\n    self._logger.debug(f\"There are currently {len(active_nodes)} active nodes\")\n\n    task = self._run_task(\n        \"column_names\", organizations=active_nodes, master=False, **kwargs\n    )\n    return task\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>The most convenient way to run verticox is using the vantage6 framework, although it is possible to run it without it.</p> <p>The architecture of verticox+ includes both components written in Java and Python. The Java components encompass everything related to the n-party scalar product protocol. In contrast, the Python components are responsible for coordination and the rest of the verticox+ algorithm.</p> <p>The architecture below shows how these components are divided. All nodes are intended to be run on different machines.</p> <p></p> <p>The verticox+ high-level architecture</p>"},{"location":"architecture/#main-python-components","title":"Main python components","text":"<p>The python components in the architecture correspond to different modules in the codebase.</p>"},{"location":"architecture/#aggregatorpy","title":"<code>aggregator.py</code>","text":"<p>The main coordinating component. The aggregator kicks off the Cox Proportional hazards analysis and provides the other components with the right starting parameters. The aggregator has access to the outcome dataset.</p>"},{"location":"architecture/#datanodepy","title":"<code>datanode.py</code>","text":"<p>The datanodes hold the feature data. They are idle until the aggregator sends them a request over gRPC.</p>"},{"location":"architecture/#nodemanagerpy","title":"<code>nodemanager.py</code>","text":"<p>Nodemanager was created to provide a unified interface for running the algorithm with or without vantage6. It is responsible for starting the aggregator and datanodes.</p>"},{"location":"architecture/#running-verticox-without-vantage6","title":"Running Verticox+ without vantage6","text":"<p>It is possible to run verticox+ without vantage6. For example, the integration test that can be found in the folder <code>integration/</code> runs the components inside a docker-compose environment without vantage6.</p>"},{"location":"architecture/#java-components","title":"Java components","text":"<p>The java components are responsible for the n-party scalar product protocol. This protocol is used at the start of the Cox proportional hazards analysis to compute \\( \\beta_{k}^{p} \\) in the Verticox algorithm. More info on this is available at the index page.</p> <p>The java components can be found in the <code>java</code> folder. </p>"},{"location":"architecture/#verticox-n-party-scalar-product-protocol-wrapper","title":"Verticox N-party scalar product protocol wrapper","text":"<p>This is a wrapper that can be used to incorperate the N-party scalar product protocol within verticox by Dai et al. The advantage of using this wrapper is that you no longer need to share the outcome among all parties. Instead this wrapper will calculate the value in a privacy preserving manner. See associated powerpoint in this repositories for a more detailed explanation.</p> <p>It is possible for party A to contain values for individual 1, party B for individual 2 and party C knows the selection criteria. It is also acceptable if A knows both the relevant values &amp; selection criteria. It can als be the case that both A &amp; B know relevant values due to a hybrid split. In this case missing records need to have a value of ?. E.g. A has record 1,2,3 B has record 4,5,6 then the data needs to look as follows: A = [A1,A2,A3,?,?,?] B= [?,?,?,B1,B1,B1] Similarly the attribute used for the selection criteria may be split up as well.</p> <p>To use this method the following needs to be done:</p> <p>1) setPrecision (default 5) 2) sumRelevantValues 3) postZ 4) sumZvalues</p>"},{"location":"architecture/#implemented-methods","title":"Implemented methods:","text":""},{"location":"architecture/#setprecision","title":"setPrecision:","text":"<p>Set the precision to be used for double values for the product protocol. Expected input:</p> <ul> <li>An int indicating the precision</li> </ul> <p>Default precision used is 5. Always make sure to keep the precision the same across the various parties involved. To keep everything aligned use setPrecisionCentral</p>"},{"location":"architecture/#sumrelevantvalues","title":"sumRelevantValues:","text":"<p>Sums the values based on the relevant individuals. Expected input:</p> <ul> <li>Predictor: the predicator to be summed</li> <li>Requirements: list of attributeRequirement indicating the relevant individuals</li> </ul> <p>Example input:</p> <pre><code>{\n  \"requirements\": [\n    {\n      \"value\": {\n        \"type\": \"numeric\",\n        \"value\": \"1\",\n        \"attributeName\": \"x6\",\n        \"id\": null,\n        \"uknown\": false\n      },\n      \"range\": false,\n      \"upperLimit\": null,\n      \"lowerLimit\": null,\n      \"name\": \"x6\"\n    }\n  ],\n  \"endpoint\": \"2\"\n}\n</code></pre>"},{"location":"architecture/#postz","title":"postZ:","text":"<p>Updates the local z-values. Expected input:</p> <ul> <li>z: array of doubles representing the z values</li> <li> </li> </ul>"},{"location":"architecture/#endpoint-name-of-the-relevant-server","title":"endpoint: name of the relevant server","text":""},{"location":"architecture/#sumzvalues","title":"sumZValues:","text":"<p>Sums the Z values based on the relevant individuals. Expected input:</p> <ul> <li>endpoint: the endpoint containing the relevant z values</li> <li>Requirements: list of attributeRequirement indicating the relevant individuals</li> </ul>"},{"location":"architecture/#cross-fold-validation","title":"cross-fold validation","text":"<p>It is possible to include k-fold crossvalidation. This can be done by setting the active records (i.e. the records present in the current fold) via the \"activateFold\" endpoint. The request looks as follows:</p> <pre><code>{\n  \"activeRecords\" : [ true, true, true, true, true, true, true, false, false, false ]\n}\n</code></pre> <p>It is important to note that user should never have the ability to manually generate folds. If folds can be manually generated it becomes possible to deduce the true data by repeatedly quering (e.g. set only 1 record to active and you get that specific value). As such the libraries should be centrally generated, outside of the control of any potential users. However, using this function properly is something that needs to covered by projects using this library.</p>"},{"location":"architecture/#soapui-example-project","title":"SOAPUI example project","text":"<p>A SOAPUI example project is also present in this repository.</p>"},{"location":"architecture/#download-jar-from-github","title":"Download jar from github:","text":"<p>A maven settings.xml is included in this project that contains a bot for downloading jar files from github packages. Unfortunatly it is not possible to download packages without a valid token, even when the project is public</p>"},{"location":"demo/","title":"Demo","text":"<p>This demo is both available as documentation page and Jupyter notebook. The notebook can be found in the git repository.</p> <p>More info about running algorithms using vantage6 can be found in the vantage6 documentation</p> <pre><code>from vantage6.client import Client\nfrom verticox.client import VerticoxClient\nimport os\nfrom verticox.config import DOCKER_IMAGE\nimport matplotlib.pyplot as plt\nimport config\nimport json\n%matplotlib inline\n\nDOCKER_IMAGE = f\"{DOCKER_IMAGE}:dev\"\nDOCKER_IMAGE = \"test\"\n</code></pre> <p>The convention is to create your own file named <code>config.py</code> that contains your credentials. You can also use it to store your v6 server address and port. For a vantage6 demo network this file could look as follows:</p> <pre><code>V6_USER = \"dev_admin\"\nV6_PASSWORD = \"password\"\nV6_SERVER_URL = \"http://localhost\"\nV6_SERVER_PORT = 7601\n</code></pre>"},{"location":"demo/#the-generic-vantage6-client","title":"The generic vantage6 client","text":"<p>We need the <code>vantage6.client.Client</code> to connect with the vantage6 server.</p> <pre><code>client = Client(config.V6_SERVER_URL, config.V6_SERVER_PORT)\n</code></pre> <pre><code> Welcome to\n                  _                     __  \n                 | |                   / /  \n__   ____ _ _ __ | |_ __ _  __ _  ___ / /_  \n\\ \\ / / _` | '_ \\| __/ _` |/ _` |/ _ \\ '_ \\ \n \\ V / (_| | | | | || (_| | (_| |  __/ (_) |\n  \\_/ \\__,_|_| |_|\\__\\__,_|\\__, |\\___|\\___/ \n                            __/ |           \n                           |___/\n\n --&gt; Join us on Discord! https://discord.gg/rwRvwyK\n --&gt; Docs: https://docs.vantage6.ai\n --&gt; Blog: https://vantage6.ai\n------------------------------------------------------------\nCite us!\nIf you publish your findings obtained using vantage6, \nplease cite the proper sources as mentioned in:\nhttps://vantage6.ai/vantage6/references\n------------------------------------------------------------\n</code></pre> <pre><code>client.authenticate(config.V6_USER, config.V6_PASSWORD)\n</code></pre> <pre><code>Successfully authenticated\n --&gt; Succesfully authenticated\n --&gt; Name: admin (id=1)\n --&gt; Organization: org_1 (id=1)\n</code></pre>"},{"location":"demo/#end-to-end-encryption","title":"End-to-end encryption","text":"<p>Some vantage6 installations use end-to-end encryption. This means that the communication between nodes is encrypted. Some of this communication is relayed through the vantage6 server but this server can't read this.</p> <pre><code>#client.setup_encryption(\"your_private_key.pem\")\nclient.setup_encryption(None)\n</code></pre>"},{"location":"demo/#getting-you-collaboration-id","title":"Getting you collaboration id","text":"<p>Vantage6 connects organizations together with the concept of collaborations. A collaboration is basically a collection of organizations that are allowed to run algorithms together.</p> <p>If you're running algorithms you sometimes need to specify your collaboration id. That is why we are retrieving it.</p> <pre><code>collaborations = client.collaboration.list()\n\nfor c in collaborations[\"data\"]:\n    print(f\"Name: {c['name']} id: {c['id']}\")\n</code></pre> <pre><code>Name: demo id: 1\n</code></pre>"},{"location":"demo/#verticoxclient","title":"VerticoxClient","text":"<p>We have created a dedicated client to work with the verticox algorithm more easily.</p> <pre><code>verticox_client = VerticoxClient(client, image=DOCKER_IMAGE)\n</code></pre>"},{"location":"demo/#column-names","title":"Column names","text":"<p>We first need to know the names of the columns at the various datasources.</p> <p>Whenever we run something on vantage6 we create a task. We can use that task later to get the results back.</p> <pre><code>task = verticox_client.get_column_names()\n</code></pre> <pre><code>                    task = self.v6client.task.create(collaboration=1,\n                                             organizations=[1, 2, 3],\n                                             name=method,\n                                             image=test,\n                                             description=,\n                                             input={'method': 'column_names', 'master': False, 'kwargs': {'database': 'default'}},\n                                             data_format=json,\n                                             database=default\n                                             )\n</code></pre>"},{"location":"demo/#getting-results","title":"Getting results","text":"<p>In the <code>VerticoxClient</code>, you can get results by running <code>task.get_results</code></p> <pre><code>results = task.get_results()\n\nfor r in results:\n    run_id = r[\"run\"][\"id\"]\n    run = client.run.get(run_id)\n    organization = run[\"organization\"][\"id\"]\n    columns = json.loads(r['result'])\n    print(f\"organization: {organization}, columns: {columns}\")\n</code></pre> <pre><code>Done!                  Results: {'data': [{'run': {'id': 572, 'link': '/api/run/572', 'methods': ['GET', 'PATCH']}, 'result': '[\"event_time\", \"event_happened\"]', 'id': 572, 'task': {'id': 374, 'link': '/api/task/374', 'methods': ['DELETE', 'GET']}}, {'run': {'id': 571, 'link': '/api/run/571', 'methods': ['GET', 'PATCH']}, 'result': '[\"Months_from_Diagnosis\", \"Prior_therapy\", \"Treatment\"]', 'id': 571, 'task': {'id': 374, 'link': '/api/task/374', 'methods': ['DELETE', 'GET']}}, {'run': {'id': 570, 'link': '/api/run/570', 'methods': ['GET', 'PATCH']}, 'result': '[\"Age_in_years\", \"Celltype\", \"Karnofsky_score\"]', 'id': 570, 'task': {'id': 374, 'link': '/api/task/374', 'methods': ['DELETE', 'GET']}}], 'links': {'first': '/api/result?task_id=374&amp;page=1', 'self': '/api/result?task_id=374&amp;page=1', 'last': '/api/result?task_id=374&amp;page=1'}}\n--&gt; Attempting to decrypt results!\norganization: 3, columns: ['event_time', 'event_happened']\n--&gt; Attempting to decrypt results!\norganization: 2, columns: ['Months_from_Diagnosis', 'Prior_therapy', 'Treatment']\n--&gt; Attempting to decrypt results!\norganization: 1, columns: ['Age_in_years', 'Celltype', 'Karnofsky_score']\n</code></pre>"},{"location":"demo/#running-cox-proportional-hazard-analysis","title":"Running cox proportional hazard analysis","text":"<p>If you want to fit a model on the entire dataset you can run <code>VerticoxClient.fit</code></p> <p>Args:</p> <ul> <li>feature_columns: a list of column names that you want to use as features</li> <li>outcome_time_column: the column name of the outcome time</li> <li>right_censor_column: the column name of the binary value that indicates if an event happened.</li> <li>feature_nodes: A list of node ids from the datasources that contain the feature columns</li> <li>outcome_node: The node id of the datasource that contains the outcome</li> <li>precision: precision of the verticox algorithm. The smaller the number, the more   precise the result. Smaller precision will take longer to compute though. The default is   1e-5</li> <li>database: If the nodes have multiple datasources, indicate the label of the datasource   you would like to use. Otherwise the default will be used.</li> </ul> <p>Make sure you specify the feature and outcome columns and the nodes that apply to your setup.</p> <pre><code>feature_columns = ['Months_from_Diagnosis', 'Age_in_years']\noutcome_time_column='event_time'\nright_censor_column='event_happened'\nfeature_nodes=[1,2]\noutcome_node=3\n</code></pre> <pre><code>task = verticox_client.fit(feature_columns=['Months_from_Diagnosis', 'Age_in_years'],\n                    outcome_time_column=outcome_time_column,\n                    right_censor_column=right_censor_column,\n                    feature_nodes=feature_nodes,\n                    outcome_node=outcome_node\n                   )\n</code></pre> <pre><code>                    task = self.v6client.task.create(collaboration=1,\n                                             organizations=[3],\n                                             name=method,\n                                             image=test,\n                                             description=,\n                                             input={'method': 'fit', 'master': True, 'kwargs': {'feature_columns': ['Months_from_Diagnosis', 'Age_in_years'], 'event_times_column': 'event_time', 'event_happened_column': 'event_happened', 'datanode_ids': [1, 2], 'central_node_id': 3, 'precision': 1e-05, 'database': 'default'}},\n                                             data_format=json,\n                                             database=default\n                                             )\n</code></pre> <pre><code>results = task.get_results()\n</code></pre> <pre><code>Done!                  Results: {'data': [{'run': {'id': 573, 'link': '/api/run/573', 'methods': ['GET', 'PATCH']}, 'result': '{\"coefs\": {\"Age_in_years\": 0.003928637132048607, \"Months_from_Diagnosis\": 0.009109284728765488}, \"baseline_hazard_x\": [1.0, 2.0, 3.0, 4.0, 7.0, 8.0, 10.0, 11.0, 12.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 22.0, 24.0, 25.0, 27.0, 29.0, 30.0, 31.0, 33.0, 35.0, 36.0, 42.0, 43.0, 44.0, 45.0, 48.0, 49.0, 51.0, 52.0, 53.0, 54.0, 56.0, 59.0, 61.0, 63.0, 72.0, 73.0, 80.0, 82.0, 83.0, 84.0, 87.0, 90.0, 92.0, 95.0, 97.0, 99.0, 100.0, 103.0, 105.0, 110.0, 111.0, 112.0, 117.0, 118.0, 122.0, 123.0, 126.0, 132.0, 133.0, 139.0, 140.0, 143.0, 144.0, 151.0, 153.0, 156.0, 162.0, 164.0, 177.0, 182.0, 186.0, 200.0, 201.0, 216.0, 228.0, 231.0, 242.0, 250.0, 260.0, 278.0, 283.0, 287.0, 314.0, 340.0, 357.0, 378.0, 384.0, 389.0, 392.0, 411.0, 467.0, 553.0, 587.0, 991.0, 999.0], \"baseline_hazard_y\": [0.005326103650510642, 0.005406326385005742, 0.005454988195933041, 0.005491439606158308, 0.005526904353807684, 0.005655915348016739, 0.0058673036461558, 0.005967908304327523, 0.006015829961280382, 0.006118354717360321, 0.006216931713352177, 0.006321381668957605, 0.006372833025452199, 0.006541132251089796, 0.006649907842504151, 0.006770443529499726, 0.006893412679744294, 0.006958393973469465, 0.007086252713859597, 0.0073921102505184345, 0.007467862784212865, 0.007546734029882196, 0.007705001541573937, 0.007856890860021334, 0.00794163174666074, 0.008027535502497091, 0.00811659543114285, 0.008211618298564724, 0.008302984017762036, 0.008406428699952284, 0.008502759812445575, 0.008607097720138047, 0.008696053906103564, 0.009127312350274449, 0.009451124796772311, 0.009582050080085053, 0.009830867000947206, 0.009960196936355435, 0.0100923491575739, 0.010226444176098927, 0.010367968950686358, 0.010520425673041641, 0.010672338419134246, 0.011009732792730993, 0.011186647793935982, 0.011349882399941637, 0.011522928646629597, 0.011870386827212332, 0.012083695433456129, 0.012291253962850118, 0.012675730471284778, 0.012893965040809557, 0.013356692936586739, 0.013854926188756621, 0.014377348138231057, 0.014679706255267584, 0.015055687175000646, 0.015683040020846504, 0.01601890986145049, 0.016663167833490446, 0.017069036818638583, 0.017544986470431227, 0.01794663350807346, 0.018405867446281306, 0.018847748729804097, 0.01931648349343108, 0.019813751484030605, 0.020344353160173006, 0.020923924712666738, 0.021522119068784023, 0.022221740723013552, 0.022964256552296333, 0.023682037497504648, 0.025287612051432845, 0.026282887255509743, 0.027361121204579557, 0.028369638660979028, 0.029456760583359127, 0.030639512851043098, 0.0322013990008373, 0.033728748005086046, 0.03514305306638737, 0.03905821813817985, 0.04119596458441893, 0.04357365549038198, 0.04608155436551294, 0.0493294047988791, 0.052555298631483616, 0.05747088630809162, 0.062480050328861565, 0.06850906589347278, 0.07585637559355607, 0.08443111898565195, 0.09466279197247372, 0.10793828114370953, 0.12642468511702307, 0.15234472961765222, 0.1903111617254013, 0.24816075394804712, 0.3651046490110427, 0.7250912096685127]}', 'id': 573, 'task': {'id': 375, 'link': '/api/task/375', 'methods': ['DELETE', 'GET']}}], 'links': {'first': '/api/result?task_id=375&amp;page=1', 'self': '/api/result?task_id=375&amp;page=1', 'last': '/api/result?task_id=375&amp;page=1'}}\n</code></pre> <pre><code>results.plot()\n</code></pre> <p></p> <pre><code>print(results.coefs)\nprint(results.baseline_hazard.x)\nprint(results.baseline_hazard.y)\n</code></pre> <pre><code>{'Age_in_years': 0.003928637132048607, 'Months_from_Diagnosis': 0.009109284728765488}\n[1.0, 2.0, 3.0, 4.0, 7.0, 8.0, 10.0, 11.0, 12.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 22.0, 24.0, 25.0, 27.0, 29.0, 30.0, 31.0, 33.0, 35.0, 36.0, 42.0, 43.0, 44.0, 45.0, 48.0, 49.0, 51.0, 52.0, 53.0, 54.0, 56.0, 59.0, 61.0, 63.0, 72.0, 73.0, 80.0, 82.0, 83.0, 84.0, 87.0, 90.0, 92.0, 95.0, 97.0, 99.0, 100.0, 103.0, 105.0, 110.0, 111.0, 112.0, 117.0, 118.0, 122.0, 123.0, 126.0, 132.0, 133.0, 139.0, 140.0, 143.0, 144.0, 151.0, 153.0, 156.0, 162.0, 164.0, 177.0, 182.0, 186.0, 200.0, 201.0, 216.0, 228.0, 231.0, 242.0, 250.0, 260.0, 278.0, 283.0, 287.0, 314.0, 340.0, 357.0, 378.0, 384.0, 389.0, 392.0, 411.0, 467.0, 553.0, 587.0, 991.0, 999.0]\n[0.005326103650510642, 0.005406326385005742, 0.005454988195933041, 0.005491439606158308, 0.005526904353807684, 0.005655915348016739, 0.0058673036461558, 0.005967908304327523, 0.006015829961280382, 0.006118354717360321, 0.006216931713352177, 0.006321381668957605, 0.006372833025452199, 0.006541132251089796, 0.006649907842504151, 0.006770443529499726, 0.006893412679744294, 0.006958393973469465, 0.007086252713859597, 0.0073921102505184345, 0.007467862784212865, 0.007546734029882196, 0.007705001541573937, 0.007856890860021334, 0.00794163174666074, 0.008027535502497091, 0.00811659543114285, 0.008211618298564724, 0.008302984017762036, 0.008406428699952284, 0.008502759812445575, 0.008607097720138047, 0.008696053906103564, 0.009127312350274449, 0.009451124796772311, 0.009582050080085053, 0.009830867000947206, 0.009960196936355435, 0.0100923491575739, 0.010226444176098927, 0.010367968950686358, 0.010520425673041641, 0.010672338419134246, 0.011009732792730993, 0.011186647793935982, 0.011349882399941637, 0.011522928646629597, 0.011870386827212332, 0.012083695433456129, 0.012291253962850118, 0.012675730471284778, 0.012893965040809557, 0.013356692936586739, 0.013854926188756621, 0.014377348138231057, 0.014679706255267584, 0.015055687175000646, 0.015683040020846504, 0.01601890986145049, 0.016663167833490446, 0.017069036818638583, 0.017544986470431227, 0.01794663350807346, 0.018405867446281306, 0.018847748729804097, 0.01931648349343108, 0.019813751484030605, 0.020344353160173006, 0.020923924712666738, 0.021522119068784023, 0.022221740723013552, 0.022964256552296333, 0.023682037497504648, 0.025287612051432845, 0.026282887255509743, 0.027361121204579557, 0.028369638660979028, 0.029456760583359127, 0.030639512851043098, 0.0322013990008373, 0.033728748005086046, 0.03514305306638737, 0.03905821813817985, 0.04119596458441893, 0.04357365549038198, 0.04608155436551294, 0.0493294047988791, 0.052555298631483616, 0.05747088630809162, 0.062480050328861565, 0.06850906589347278, 0.07585637559355607, 0.08443111898565195, 0.09466279197247372, 0.10793828114370953, 0.12642468511702307, 0.15234472961765222, 0.1903111617254013, 0.24816075394804712, 0.3651046490110427, 0.7250912096685127]\n</code></pre>"},{"location":"demo/#crossvalidation","title":"Crossvalidation","text":"<p>It's also possible to run crossvalidation. The parameters are similar to the <code>fit</code> method.</p> <pre><code>crossval_task = verticox_client.cross_validate(feature_columns=feature_columns,\n                    outcome_time_column=outcome_time_column,\n                    right_censor_column=right_censor_column,\n                    feature_nodes=feature_nodes,\n                    outcome_node=outcome_node,\n                    precision=0.01,\n                   )\n</code></pre> <pre><code>                    task = self.v6client.task.create(collaboration=1,\n                                             organizations=[3],\n                                             name=method,\n                                             image=test,\n                                             description=,\n                                             input={'method': 'cross_validate', 'master': True, 'kwargs': {'feature_columns': ['Months_from_Diagnosis', 'Age_in_years'], 'event_times_column': 'event_time', 'event_happened_column': 'event_happened', 'datanode_ids': [1, 2], 'central_node_id': 3, 'convergence_precision': 0.01, 'database': 'default'}},\n                                             data_format=json,\n                                             database=default\n                                             )\n</code></pre> <pre><code>crossval_result = crossval_task.get_results()\n</code></pre> <pre><code>Done!                  Results: {'data': [{'run': {'id': 582, 'link': '/api/run/582', 'methods': ['GET', 'PATCH']}, 'result': '[[0.54, 0.5075757575757576, 0.46893491124260356, 0.48714285714285716, 0.4935483870967742], [{\"Age_in_years\": 0.002558924490585923, \"Months_from_Diagnosis\": 0.007024750113487244}, {\"Age_in_years\": -0.0010991113958880305, \"Months_from_Diagnosis\": 0.008867615833878517}, {\"Age_in_years\": 0.008877694606781006, \"Months_from_Diagnosis\": 0.006313976366072893}, {\"Age_in_years\": 0.0029411751311272383, \"Months_from_Diagnosis\": 0.013149532489478588}, {\"Age_in_years\": 0.0037725227884948254, \"Months_from_Diagnosis\": 0.007962649688124657}], [[[1.0, 3.0, 4.0, 7.0, 8.0, 10.0, 11.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 24.0, 25.0, 27.0, 29.0, 30.0, 31.0, 33.0, 35.0, 36.0, 42.0, 43.0, 45.0, 48.0, 49.0, 51.0, 52.0, 53.0, 54.0, 56.0, 59.0, 61.0, 63.0, 72.0, 80.0, 82.0, 83.0, 84.0, 87.0, 90.0, 92.0, 95.0, 97.0, 99.0, 100.0, 103.0, 105.0, 111.0, 112.0, 118.0, 122.0, 123.0, 126.0, 132.0, 133.0, 139.0, 140.0, 143.0, 144.0, 162.0, 164.0, 182.0, 186.0, 200.0, 201.0, 216.0, 228.0, 231.0, 242.0, 250.0, 278.0, 283.0, 287.0, 340.0, 357.0, 378.0, 411.0, 467.0, 553.0, 587.0, 991.0, 999.0], [0.007412674171186806, 0.007488651104566306, 0.007553137854552637, 0.007616950478186405, 0.007839196405276241, 0.008026241534241377, 0.00819524115891717, 0.008278110821491894, 0.008360257198926, 0.008533668095838939, 0.00862031689279331, 0.0089021129212728, 0.008993093181999517, 0.009194599036312062, 0.009402147741229725, 0.009617500928931252, 0.010122215933975, 0.010250846466982317, 0.010384509430768803, 0.010514866050800986, 0.010641131853410268, 0.010782099988729227, 0.010926104409106895, 0.011075740212450417, 0.011233173267758757, 0.011389860930467939, 0.011550163516722951, 0.011721476852802056, 0.011877787808349666, 0.012556707612963097, 0.012937250190888257, 0.013156500212188468, 0.01336672065689876, 0.013587294822120774, 0.013812060149998348, 0.014042580496873644, 0.014287662086639197, 0.014548161347418702, 0.01480849838371187, 0.015094601320500676, 0.015368732062111399, 0.015658801558784866, 0.016255256110648028, 0.01661346655404249, 0.016967870013903524, 0.01765669177389395, 0.01804340055889348, 0.01887195433786103, 0.019787641484294516, 0.020783401213685153, 0.02135099981730697, 0.02251275221160828, 0.023146472894972164, 0.023850814239039956, 0.024671196821682385, 0.02540814784696718, 0.026242697852422274, 0.02707919531249837, 0.027973181245286565, 0.028935174086523758, 0.029975969458010312, 0.031126751635541745, 0.032343316228649666, 0.03510692384148549, 0.036816001390014876, 0.038500646887817534, 0.0403505524129925, 0.04241869715441821, 0.04507777776733487, 0.0478134477591911, 0.05053307005531846, 0.058026028289138554, 0.062386755611926435, 0.06748735999440235, 0.07385896691308537, 0.08075070624566667, 0.09113695355800643, 0.10299902814870897, 0.11851273721519336, 0.13844098894293486, 0.16657670134067798, 0.20795946418344435, 0.27286083530870087, 0.40319830556850433, 0.8005318768357108]], [[1.0, 2.0, 4.0, 7.0, 8.0, 10.0, 11.0, 12.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 22.0, 25.0, 27.0, 30.0, 31.0, 33.0, 35.0, 43.0, 44.0, 45.0, 48.0, 49.0, 51.0, 52.0, 54.0, 56.0, 59.0, 63.0, 72.0, 73.0, 80.0, 83.0, 84.0, 87.0, 90.0, 92.0, 95.0, 97.0, 99.0, 100.0, 105.0, 110.0, 111.0, 112.0, 117.0, 118.0, 122.0, 123.0, 132.0, 133.0, 139.0, 140.0, 143.0, 144.0, 151.0, 153.0, 156.0, 162.0, 164.0, 177.0, 186.0, 201.0, 231.0, 250.0, 260.0, 278.0, 283.0, 287.0, 314.0, 357.0, 384.0, 389.0, 392.0, 411.0, 467.0, 553.0, 587.0, 991.0, 999.0], [0.008966289610198776, 0.009142159691272437, 0.009253070391106939, 0.0093376997900685, 0.009605435597726362, 0.010047871522299075, 0.010148880137669696, 0.010257753309008934, 0.010472491025914504, 0.010687966446109946, 0.010927308041448218, 0.011045284623731558, 0.011164902529162427, 0.01142461182760136, 0.011691368722145995, 0.0119593371576601, 0.012098454945289534, 0.012433379814089427, 0.012590358831510764, 0.012755565761948858, 0.01307976520410939, 0.013250129021805291, 0.013425379276196291, 0.013616347162072237, 0.01381176361746975, 0.013995782964100385, 0.014183946089616067, 0.014385134502009693, 0.01524964554683303, 0.015959451759573164, 0.016209556212461333, 0.016493194100663387, 0.01675508888481482, 0.017053916947674833, 0.017345684752218066, 0.017636586133763992, 0.018295548695324217, 0.01862422535285887, 0.018966099222354996, 0.019314409926256954, 0.019753324695054923, 0.02015980847172243, 0.02098104797375358, 0.021419886936288216, 0.022336929413495254, 0.02341103587887881, 0.023986809186082963, 0.02469778537342617, 0.025936420776763842, 0.02661805763344831, 0.02807734949578077, 0.02891054741458883, 0.029957920611812187, 0.03085140399404535, 0.031822813595255815, 0.03280672887695535, 0.033863050991900505, 0.03499874066661077, 0.03627466463592451, 0.03759305291350223, 0.03910891947679908, 0.04079438594263142, 0.042433099951771164, 0.04426730846996186, 0.046446758390754295, 0.04888009180954917, 0.05129045073858505, 0.05468611213078991, 0.06179509229435451, 0.06592068181672267, 0.07054745962322577, 0.07612094876515298, 0.08213833909609637, 0.09079570630435706, 0.10106291584117934, 0.11309728840473329, 0.12807825403721812, 0.14583877797233294, 0.16962392027767426, 0.20320805526522007, 0.25174251042763773, 0.33270486668420507, 0.48968453649451227, 0.9540307424684884]], [[1.0, 2.0, 3.0, 7.0, 8.0, 10.0, 11.0, 12.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 22.0, 24.0, 25.0, 27.0, 29.0, 30.0, 31.0, 33.0, 35.0, 36.0, 42.0, 44.0, 45.0, 48.0, 49.0, 51.0, 52.0, 53.0, 54.0, 56.0, 59.0, 61.0, 72.0, 73.0, 80.0, 82.0, 84.0, 87.0, 90.0, 92.0, 95.0, 97.0, 99.0, 100.0, 103.0, 105.0, 110.0, 111.0, 112.0, 117.0, 123.0, 126.0, 132.0, 133.0, 139.0, 143.0, 144.0, 151.0, 153.0, 156.0, 162.0, 164.0, 177.0, 182.0, 200.0, 216.0, 228.0, 231.0, 242.0, 250.0, 260.0, 278.0, 283.0, 287.0, 314.0, 340.0, 357.0, 378.0, 384.0, 389.0, 392.0, 467.0, 553.0, 587.0, 991.0, 999.0], [0.005114953165334537, 0.005152537021776577, 0.005202261851563439, 0.005242979688478247, 0.005343128681573049, 0.005509271807568896, 0.005573632719210167, 0.005625095976143411, 0.005746869954023716, 0.005862844382403917, 0.0059804400702960555, 0.006039741239065371, 0.006237426517896001, 0.006356223248335501, 0.00642935743459919, 0.006498302965647335, 0.006578483798330266, 0.006726732565463294, 0.007098469008522302, 0.007191573082274729, 0.007291550414769116, 0.007489611937695699, 0.007590067601977053, 0.007697166108787432, 0.007805364270039375, 0.007917071766604911, 0.008051253938452956, 0.008184417777664082, 0.00831234697040116, 0.008460387499500064, 0.008562927579334252, 0.008698804192902266, 0.008951792170967036, 0.009109841087671374, 0.009420360112191504, 0.009562704943568067, 0.009730512068794942, 0.009899666589303713, 0.010092347852947927, 0.010289360605590967, 0.010515607050274583, 0.010737524576600894, 0.01094654701621935, 0.011136799141842922, 0.011363458867181419, 0.011607070208016003, 0.0118448538661567, 0.01210137198020159, 0.012367523499565427, 0.012670505480606177, 0.013176000017488813, 0.013519050781610361, 0.013932746338658467, 0.014284444050285752, 0.014654807602832642, 0.015317497351504344, 0.015717300765412, 0.016188452788960157, 0.016621323546967656, 0.01711780013569082, 0.01764829105390504, 0.018224564823073348, 0.01884061981539214, 0.019574672135007215, 0.02033541141228161, 0.021116731781291143, 0.022859978624421372, 0.02396124764641052, 0.025159506877761074, 0.026322442447399133, 0.027443823399241875, 0.02882361229429652, 0.030060948574734934, 0.03164870303849792, 0.03364344081781211, 0.035663699964175094, 0.03773468398482646, 0.040627816523960386, 0.04343851952718562, 0.0478076030255727, 0.0518778944173271, 0.05748462170869814, 0.06418766187147813, 0.07271144803128954, 0.08185842793587544, 0.09560045145889355, 0.1164879095903916, 0.14712127789088816, 0.19011258894813185, 0.28132891687447, 0.5739785818440031]], [[1.0, 2.0, 3.0, 4.0, 7.0, 8.0, 10.0, 12.0, 13.0, 15.0, 16.0, 18.0, 19.0, 20.0, 21.0, 22.0, 24.0, 25.0, 27.0, 29.0, 30.0, 31.0, 35.0, 36.0, 42.0, 43.0, 44.0, 48.0, 51.0, 52.0, 53.0, 54.0, 61.0, 63.0, 73.0, 80.0, 82.0, 83.0, 87.0, 92.0, 95.0, 97.0, 99.0, 100.0, 103.0, 105.0, 110.0, 111.0, 112.0, 117.0, 118.0, 122.0, 123.0, 126.0, 133.0, 140.0, 144.0, 151.0, 153.0, 156.0, 162.0, 164.0, 177.0, 182.0, 186.0, 200.0, 201.0, 216.0, 228.0, 231.0, 242.0, 250.0, 260.0, 278.0, 283.0, 314.0, 340.0, 357.0, 378.0, 384.0, 389.0, 392.0, 411.0, 587.0], [0.006677596104370252, 0.006805337326586104, 0.006891026123642256, 0.0069475423115454805, 0.007002907642550343, 0.007069995063288799, 0.007351347028092475, 0.007510434651390282, 0.007665810972184938, 0.007738900260533041, 0.007899055324470005, 0.007976669066635387, 0.008235757173862487, 0.008406954639410042, 0.008501250932123765, 0.008596162995960863, 0.00869235613333566, 0.008886071270507006, 0.009369117152710379, 0.009487622254819604, 0.009610987571576933, 0.009860762124005697, 0.01010131159348087, 0.010235572433016926, 0.01037675377484684, 0.0105228033412427, 0.010672707609182376, 0.010841367655664144, 0.011000889134379084, 0.011813069901578018, 0.01215534086438822, 0.012369106999445779, 0.012764207494593468, 0.012968140700768151, 0.013195884635419455, 0.013422249835398204, 0.013948229417731725, 0.014225452283698455, 0.014478813135223886, 0.015006801241834141, 0.015321497721938651, 0.015900636725614602, 0.016231401477084653, 0.016577317583818016, 0.017339707559401635, 0.018184391377343467, 0.0186605434803606, 0.019304802989258886, 0.019797499020247345, 0.02031674021300906, 0.021330372737393615, 0.02198651833428439, 0.022834422681731772, 0.023490364918210778, 0.024262502073638677, 0.025000035694588703, 0.025807821962905916, 0.026681344922709734, 0.02774310960460509, 0.02890328956915924, 0.029983621171444253, 0.0311891886360759, 0.03270680719510338, 0.034392499835240724, 0.03591426304701032, 0.0375896200637141, 0.03955368050221351, 0.042376165097667416, 0.04508801593705151, 0.04758370490344786, 0.055011408648175456, 0.05905566448917129, 0.06395969196797043, 0.06936851444392, 0.07688481953736097, 0.08464767134977737, 0.09637806317074162, 0.11112286075245584, 0.13171852315530524, 0.1583308112447384, 0.19832396769049612, 0.26245074013981223, 0.39637348101039255, 0.8105544598504546]], [[1.0, 2.0, 3.0, 4.0, 7.0, 8.0, 10.0, 11.0, 12.0, 13.0, 18.0, 19.0, 20.0, 21.0, 22.0, 24.0, 25.0, 29.0, 30.0, 31.0, 33.0, 36.0, 42.0, 43.0, 44.0, 45.0, 49.0, 51.0, 52.0, 53.0, 54.0, 56.0, 59.0, 61.0, 63.0, 72.0, 73.0, 80.0, 82.0, 83.0, 84.0, 87.0, 90.0, 95.0, 99.0, 100.0, 103.0, 110.0, 111.0, 117.0, 118.0, 122.0, 126.0, 132.0, 139.0, 140.0, 143.0, 151.0, 153.0, 156.0, 162.0, 177.0, 182.0, 186.0, 200.0, 201.0, 216.0, 228.0, 231.0, 242.0, 260.0, 287.0, 314.0, 340.0, 378.0, 384.0, 389.0, 392.0, 411.0, 467.0, 553.0, 991.0, 999.0], [0.006757802032273075, 0.0068842047675952015, 0.006959543159843521, 0.00701837908001735, 0.007075960449716788, 0.007284794826132239, 0.007625025105720839, 0.007791265789024771, 0.007871497748856728, 0.008044452772307363, 0.0082135351058008, 0.008397722637853268, 0.008488164367117808, 0.008682120291903723, 0.008882616075838439, 0.008989153565978097, 0.009200574796477106, 0.00943277639773436, 0.009556477715393481, 0.009807047377791554, 0.01005157265267764, 0.010188327399739273, 0.010329512653801352, 0.010481229518722962, 0.010627502404540313, 0.010793164351724817, 0.010950198390594048, 0.011093244234807526, 0.011583120158880567, 0.012103489493081947, 0.012313835870964868, 0.012722280260117893, 0.012935235089651763, 0.013156196290296561, 0.013382220373246292, 0.01362067670987006, 0.013880001332229632, 0.014141792738663058, 0.014726145960318095, 0.015037236713295146, 0.015329969745350528, 0.015642770237511577, 0.016282398745590936, 0.01667299701511806, 0.01700576966072517, 0.017807740384196108, 0.018221520348413747, 0.019115206495777377, 0.019729230401671568, 0.02080413665456635, 0.021893126938936972, 0.02258276213553009, 0.023388976434608647, 0.024158867551700398, 0.024915268581029725, 0.02573854516355262, 0.0266288296054466, 0.027611505712072097, 0.028744400508410636, 0.029965663934987338, 0.031183528199356214, 0.033980563135643446, 0.035750579479653426, 0.03747033559462469, 0.039364739214346474, 0.041460864171433784, 0.04425072523130757, 0.047108918619220674, 0.04988685519908714, 0.053881161456341926, 0.05798202652552451, 0.06244704561862874, 0.06921226334654902, 0.07638870610492549, 0.08538002662343229, 0.09621777927693181, 0.10947684835643319, 0.12737953160894583, 0.15346160797028413, 0.19262267544746065, 0.25654330797575636, 0.37246571804146944, 0.7413606761751308]]]]', 'id': 582, 'task': {'id': 382, 'link': '/api/task/382', 'methods': ['DELETE', 'GET']}}], 'links': {'first': '/api/result?task_id=382&amp;page=1', 'self': '/api/result?task_id=382&amp;page=1', 'last': '/api/result?task_id=382&amp;page=1'}}\n</code></pre> <pre><code>crossval_result.plot()\n</code></pre> <p></p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#building","title":"Building","text":"<p>The makefile contains the necessary commands to build the verticox+ package.</p> <p>If you wish to build the vantage6 docker image from scratch, use: <pre><code>make docker\n</code></pre></p>"},{"location":"development/#testing","title":"Testing","text":"<p>There are several types of tests in this repository: - Unit tests - Integration test - vantage6 tests</p>"},{"location":"development/#unit-tests","title":"Unit tests","text":"<p>The unit tests for the python components can be found in <code>python/tests</code> and can be run with pytest. The unit tests for the java components are found in <code>java/src/test</code> and can be run with maven.</p>"},{"location":"development/#integration-test","title":"Integration test","text":"<p>The files for the integration test can be found in <code>integration/</code>. It contains configuration files for the java components, a <code>data</code> directory with a small dataset, a docker-compose file to run all components, and a .env-example file that can be used to create your specific .env file. The .env file is required to indicate the absolute path to the directory that contains the jar file for the java components after you built them with maven.</p> <p>The integration test can be run with <code>docker compose up</code>.</p>"},{"location":"development/#vantage6-tests","title":"Vantage6 tests","text":"<p>The main vantage6 test is the script <code>python/tests/test_verticox_v6.py</code>. This can be run as a command-line tool and has parameters to configure the test to your needs:</p> <pre><code>./test_verticox_v6.py --help\nUsage: test_verticox_v6.py [OPTIONS] host port user password\n\nArguments:\n  host\n  port\n  user\n  password\n\nOptions:\n  --image=STR          (default: harbor2.vantage6.ai/algorithms/verticox:latest)\n  --method=STR         (default: fit)\n  --private-key=STR\n\nOther actions:\n  -h, --help          Show the help\n</code></pre> <p>You could run the test on a local vantage6 network. You have to make sure your nodes have access to data that is suitable for survival analysis.</p> <pre><code>./test_verticox_v6.py http://localhost 7601 dev_admin password\n</code></pre>"},{"location":"development/#further-development","title":"Further development","text":"<p>If this code would be developed further, it would be good to add the following features:</p>"},{"location":"development/#sample-size-threshold","title":"Sample size threshold","text":"<p>In order to further prevent data leakage, a threshold should be added to prevent the  analysis from being run if the sample size is below a certain threshold. </p>"},{"location":"development/#upgrade-to-latest-vantage6-version","title":"Upgrade to latest vantage6 version","text":"<p>The current version of vantage6 that is being used is 4.7.1. In order to make it compatible with the latest version, the code should comply with the new client api.</p>"},{"location":"security_considerations/","title":"Security risks","text":"<p>It is important to be transparent about the security risks associated with using Verticox+. The following points should be considered:</p>"},{"location":"security_considerations/#record-level-aggregations","title":"Record level aggregations","text":"<p>While verticox+ does not share raw data with other parties. It does share record level aggregations, feature nodes do share record-level aggregations of feature data. Figure 1 shows how parties  exchange data between eachother. It is important to note that institution 1 and 2 (the feature  nodes) send \\( \\beta_k^T x_{k} \\) to the aggregator. In this case \\(\\beta_k\\) refers to the  coefficients for the covariates that are present on feature node k. More importantly, \\(x_{k}\\)  refers to the raw values for the features at institution \\( k \\). Therefore, \\( \\beta_k^T x_{k}  \\) is a vector that has an aggregation of the features for every sample at institution \\( k \\),  based on the current value of the covariates.</p> <p></p> <p>Figure 1: Overview of data exchange between parties</p>"},{"location":"security_considerations/#node-to-node-communication-in-vantage6","title":"Node-to-node communication in vantage6","text":"<p>This algorithm makes use of the node-to-node communication in vantage6, as it was available in  version 4.7.1. This provides a direct channel of communication between nodes based on VPN. This  means that a vpn server provides a separate channel of communication between nodes. The setup of  this VPN is described in the eduvpn section of the vantage6 documentation. The implementation of this solution in your  infrastructure needs to be thoroughly reviewed.</p>"}]}